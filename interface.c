#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "store.h" // include headrer file

int main()
{
    pid_t pid;
    int error;
    int interface[2], server[2]; // create 2 pipes
    int num;
    char input[SIZE], output[SIZE]; //user input and output for user
    char buf1[SIZE], buf2[SIZE] ;

    if(pipe(&interface[0]) == -1)   //check if first pipe opened right
    {
        perror("Interface pipe opening failed.");
        exit(1);
    }
    if(pipe(&server[0]) == -1)  //check if second pipe opened right
    {
        perror("Server pipe opening failed");
        exit(2);
    }

    printf("Pipes opened successfully. Forking.\n");
    int i;  //declare outside for loop to prevent C99 error generated by csci2 machine
    for(i = 0; i<SIZE; i++) //clears out the input
        input[i] = '\0';

    pid = fork();   //fork to create child process
    if(pid == 0)    //child process
    {
        close(interface[1]); //close write function of interface
        close(server[0]);   //close read function of server

        sprintf(buf1, "%d",interface[0]);
        sprintf(buf2, "%d",server[1]);

        error = execl("./server", "Server", buf1, buf2, 0); //exec function

        if(error == -1) //throws an error if exec function goes wrong
        {
            printf("Error while executing. Errno: %d\n",errno);
            exit(3);
        }
    }
    else if (pid > 0)//parent process
    {
        close(interface[0]);    //close read function of interface
        close(server[1]);   //close write function of server

        while(1)
        {
            printf("Input command: \n");
            scanf("%s", input);

            error = write(interface[1], input, strlen(input));
            if(error == -1) //throws an error if wirte function does not work
            {
                printf("Error while writing to server. Errno: %d\n",errno);
                exit(4);
            }
            int j;
            for(j = 0; j < SIZE; j++)   //clears out output array
                output[j] = '\0';

            error = read(server[0], output, SIZE);
            if(error == -1) //throws an error if read function does not work
            {
                printf("Error while reading from server. Errno: %d\n",errno);
                exit(5);
            }
            output[error] = '\0';
            printf("Response: %s\n",output);

            if(strncmp(input, "exit", 4) == 0)//compares 2 c-strings using strncmp
            {
                error = waitpid(pid, &num, 0);
                if(error == -1)//throws an error if waitpid function does not work
                {
                    printf("Error in waitpid. Error: %d\n",error);
                    exit(6);
                }
                printf("Interface: child process (%d) completed.\n",pid);
                printf("Interface: child process exit status = %d.\n",get(num));
                //getnum used to get the exit status
                printf("Interface: complete\n");
                exit(8);
            }
        }
    }
    else    //if not parent or child || if pid returns value <0
    {
         printf("Error wile forking\n");
                exit(9);
    }
    return 0;
}
